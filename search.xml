<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分布式键值存储</title>
      <link href="/2023/11/21/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8/"/>
      <url>/2023/11/21/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式键值存储的架构"><a href="#分布式键值存储的架构" class="headerlink" title="分布式键值存储的架构"></a>分布式键值存储的架构</h1><p>分布式键值存储也被称为分布式哈希表，它将键值对分布在许多服务器上。   </p><h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>CAP理论指出，一个分布式系统不可能同时提供这三种保证中的两种以上：一致性、可用性和容忍度。</p><p><strong>一致性</strong>：一致性意味着所有客户在同一时间看到相同的数据，无论他们连接到哪个节点。</p><p><strong>可用性</strong>：可用性意味着任何i请求数据的客户端都能得到响应，即使有些节点发生了故障。</p><p><strong>分区容忍度</strong>：分区表示两个节点之间的通信中断。分区容忍度意味着尽管网络分区，系统仍能继续运行。</p><p>CAP理论指出，必须牺牲三个属性中的一个来支持三个属性中的两个，如图。</p><p><img src="/../imags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8/v2-e1078c8acab3e722fa0eb62ed97b7456_r.jpg"></p><p>现在，键值存储是根据它们支持的两个CAP特性来分类的。</p><p><strong>CP</strong>（一致性和分区容忍）系统：CP键值存储支持一致性和分区容忍，同时牺牲了可用性。</p><p><strong>AP</strong>（可用性和分区容忍度）系统：一个AP键值存储支持可用性和分区容忍度，同时牺牲了一致性。</p><p><strong>CA</strong>（一致性和可用性）系统：CA键值存储支持一致性和可用性，同时牺牲了分区容忍度。由于网络故障是不可避免的，一个分布式系统必须容忍网络分区。因此，CA系统不能存在于现实世界的应用中。</p><h2 id="系统组件"><a href="#系统组件" class="headerlink" title="系统组件"></a>系统组件</h2><p>核心组件和技术。</p><ol><li>数据分区</li><li>数据复制</li><li>一致性</li><li>不一致的解决</li><li>故障处理</li><li>系统架构图</li><li>写入流程</li><li>读取流程</li></ol><h3 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h3><p>对于大型应用来说，将数据全部放在一台服务器上是不可行的。我们需要将数据分区，放在多个服务器上。   </p><p>当然，我们最好是能让数据均分分布，并且在减少和增加节点时减少数据移动。 </p><p>可以用一致性hash来解决这个问题。   </p><p>首先将服务器放在一个环置地哈希环上，然后将加入地键值对散列到环上，并存储在顺时针方向移动到的遇到的第一个服务器（节点上）。可以动态的改变节点的位置，已让负载更加均衡。</p><p>优点：</p><ol><li>自动扩展：可以根据负载自动添加和删除服务器。</li><li>异构性：服务器的虚拟节点数量与服务器容量成正比。</li></ol><h3 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h3><p>为了实现高可用性和可靠性，数据必须在N个服务器上进行异步复制。N可以自己设置。至于要复制到哪些服务器上，可以根据不同的策略来分配。比如说按顺序分配，或者是根据数据大小（复制给数据量较小的服务器中），地理位置等等。</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>因为数据要在多个节点上复制，因此要跨副本同步。</p><p>Quorum共识可以保证读写操作的一致性。</p><p>定义：</p><p>​         N &#x3D; 副本数</p><p>​         W &#x3D; 大小为 W 的写入仲裁。要使写入操作被视为成功，必须从 W 个副本确认写入操作。</p><p>​          R  &#x3D; 大小为 R 的读取仲裁。要使读取操作被视为成功，读取操作必须等待至少 R 个副本的响应。</p><p>举例说明：</p><p>​      假设说w&#x3D;1，那就是说在所有存储该数据的服务器中只要有一个返回确认，说明写入成功即可。R同理。</p><p>   W、R和N的配置是一个典型的延迟和一致性之间的权衡。如果W &#x3D; 1或R &#x3D; 1，一个操作就会快速返回，因为协调者只需要等待任何一个副本的响应。如果W或R &gt; 1，系统提供更好的一致性；然而，查询会更慢，因为协调者必须等待最慢的副本的响应。</p><p>​     如果W + R &gt; N，强一致性得到保证，因为必须至少有一个重叠节点拥有最新的数据以保证一致性。</p><p>​     如何配置N、W和R以适应我们的使用情况？下面是一些可能的设置。  </p><p>​      如果R &#x3D; 1，W &#x3D; N，系统被优化为快速读取。  </p><p>​      如果W &#x3D; 1，R &#x3D; N，系统被优化为快速写入。  </p><p>​       如果W + R &gt; N，强一致性得到保证（通常N &#x3D; 3，W &#x3D; R &#x3D; 2）。</p><p>​       如果W + R &lt;&#x3D; N，强一致性就得不到保证。  </p><p>​       根据需求，可以调整W、R、N的值，以达到所需的一致性水平</p><h3 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h3><p>一致性模型是设计键值存储时需要考虑的其他重要因素。一致性模型定义了数据的一致性程度，存在着广泛的可能的一致性模型。</p><ul><li>强一致性：任何读操作都会返回一个与最新的写数据项的结果相对应的值。客户端永远不会看到过期的数据。</li><li>弱一致性：后续的读操作可能看不到最新的值。</li><li>最终一致性：这是弱一致性的一种特殊形式。只要有足够的时间，所有的更新都会被传播，所有的副本都是一致的。</li></ul><p>强一致性通常是通过强迫一个副本不接受新的读&#x2F;写，直到每个副本都同意当前的写来实现。这种方法对于高可用系统来说并不理想，因为它可能会阻止新的操作。Dynamo和Cassandra采用最终一致性，这是我们推荐的键值存储的一致性模型。从并发写入来看，最终一致性允许不一致的值进入系统，并迫使客户端读取这些值来进行调节。</p><h3 id="不一致的解决：版本化"><a href="#不一致的解决：版本化" class="headerlink" title="不一致的解决：版本化"></a>不一致的解决：版本化</h3><p>复制提供了高可用性，但会导致副本之间的不一致。可以用版本化和向量锁来解决不一致问题。版本化意味着将每个数据修改视为新的不可变数据版本。</p><p>矢量时钟，有点难以理解所以就暂时不写了。</p><h3 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h3><h4 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h4><p>第一种方法：全联通组播。</p><p>缺点：如果服务器太多的话，性能很差，需要将多个服务器联通，资源占用严重。</p><p>第二种方法：分散式故障检测方法。</p><p>gossip协议：</p><ul><li>每个节点维护一个节点成员列表，其中包含成员ID和心跳计数器。</li><li>每个节点定期增加其心跳计数器。</li><li>每个节点定期向一组随机节点发送心跳，这些节点依次传播到另一组节点。</li><li>一旦节点收到心跳，成员列表将更新为最新信息。</li><li>如果心跳没有增加超过预定义的时间，则该成员被视为离线。</li></ul><p><img src="/../imags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8/v2-7a528fff34928f7e4d9d0ff23498f1b7_r.jpg"></p><p>如图所示，节点S0维护着左侧所示的节点成员列表。当S2的心跳计数器很长时间没有增加时，S0会向一组随机节点发送包括S2的信息的心跳，一旦其他节点确认S2的心跳计数器长时间没有更新，那么节点S2就会被标记下来，并将这个信息传播给其他节点。</p><p>第三种方法：设置一个Φ值，来判断节点是否产生故障（累积故障检测器）</p><p>因为网络传输等原因，可能会产生误判的情况，所以对于节点是否故障，不能只采用直接检测法。可以设置一个Φ值来判断。Φ值越大，就证明怀疑度越低，比如说Φ&#x3D;1，则表示节点出现故障的概率为百分之20，Φ&#x3D;10代表节点出现故障的概率为百分之10.如果节点的Φ值超过了预设的阈值，系统就会将其视为离线节点，并且会尝试避免与该节点进行通信，防止因通信问题导致系统出现故障。</p><p>这种方法容错性更好，而且可以动态适应网络延迟和负载情况。</p><h4 id="处理暂时性地故障"><a href="#处理暂时性地故障" class="headerlink" title="处理暂时性地故障"></a>处理暂时性地故障</h4><p>通过 gossip 协议检测到故障后，系统需要部署一定的机制来保证可用性。在严格的仲裁方法中，可以阻止读取和写入操作，如仲裁共识部分所示。一种称为“sloppy quorum”的技术用于提高可用性。系统没有强制执行法定人数要求，而是选择前 W 个健康的服务器进行写入，并选择前 R 个健康的服务器进行哈希环上的读取。离线服务器被忽略。如果由于网络或服务器故障导致服务器不可用，另一台服务器将临时处理请求。当宕机的服务器启动时，更改将被推回以实现数据一致性。这个过程称为提示切换（Hinted handoff）。</p><h4 id="处理永久性故障"><a href="#处理永久性故障" class="headerlink" title="处理永久性故障"></a>处理永久性故障</h4><p>提示切换用于处理临时故障。如果副本永久不可用怎么办？为了处理这种情况，我们实现了一个反熵协议来保持副本同步。反熵涉及比较副本上的每条数据并将每个副本更新到最新版本。 Merkle 树用于不一致检测和最小化传输的数据量。  </p><p>“哈希树或 Merkle 树是一种树，其中每个非叶节点都用其子节点的标签或值（如果是叶）的哈希值进行标记。哈希树允许对大型数据结构的内容进行有效和安全的验证”。</p><p>简单来说，就是将key空间划分为桶，然后将桶的数据用统一的散列方法进行散列（桶中的key的数量是一致的）。然后再为桶创建哈希节点，通过哈希节点，将这些桶构建成树，直到根节点。</p><p>要判断两个 Merkle 树是否一致（也就是两个服务器的数据是否同步），那么就从根节点判断，如果节点值相同这证明数据同步成功，如果不同，那么就要往左右子树走，找到最终不相同的子节点（也就是桶里的数据），然后将数据同步。</p><h4 id="处理数据中心故障"><a href="#处理数据中心故障" class="headerlink" title="处理数据中心故障"></a>处理数据中心故障</h4><p>数据中心中断可能由于停电、网络中断、自然灾害等原因发生。要构建能够处理数据中心中断的系统，跨多个数据中心复制数据非常重要。即使一个数据中心完全离线，用户仍然可以通过其他数据中心访问数据。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>目标&#x2F;问题</th><th>技术</th></tr></thead><tbody><tr><td>存储海量数据的能力</td><td>使用一致性哈希将数据分发给不同的服务器</td></tr><tr><td>高可靠读取</td><td>数据复制；多数据中心</td></tr><tr><td>高可靠写入</td><td>版本化和使用向量时钟解决冲突</td></tr><tr><td>数据分区</td><td>一致性哈希</td></tr><tr><td>增量可扩展性</td><td>一致性哈希</td></tr><tr><td>异构性</td><td>一致性哈希</td></tr><tr><td>可调节的一致性</td><td>Quorun共识</td></tr><tr><td>处理暂时性故障</td><td>Sloppy quorum和提示切换（hinted handoff）</td></tr><tr><td>处理永久性故障</td><td>Merkle树</td></tr><tr><td>处理数据中心故障</td><td>跨数据中心复制</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/11/07/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E8%AE%BA%E6%96%87/"/>
      <url>/2023/11/07/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E8%AE%BA%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="如何阅读论文"><a href="#如何阅读论文" class="headerlink" title="如何阅读论文"></a>如何阅读论文</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>研究生通常都需要阅读大量的论文，但很多初学者都是盲目的阅读，从头阅读到尾，以至于不能有效的阅读论文。在这里提出了一个三遍阅读法，来提高阅读论文的效率。</p><h2 id="关键思想"><a href="#关键思想" class="headerlink" title="关键思想"></a>关键思想</h2><p>最多阅读论文三遍，但不是从头开始一直读到尾，而是应该带有目的性的去阅读。      </p><p>每一遍阅读都要完成特定的目标，并且是建立在前一遍地基础上；第一遍阅读是要对论文有一个总体的了解。第二遍阅读要掌握论文的内容，但不了解其细节（比如证明假设这些可以不细看）。第三遍就要更深入的理解论文。</p><h2 id="三遍法"><a href="#三遍法" class="headerlink" title="三遍法"></a>三遍法</h2><h3 id="第一遍"><a href="#第一遍" class="headerlink" title="第一遍"></a>第一遍</h3><p>快速阅读论文，大概了解一下论文的思想和研究领域。通常包含以下几个步骤。</p><ol><li>仔细阅读标题、摘要和引言</li><li>阅读章节和子章节标题，但忽略其他所有内容</li><li>阅读结论</li><li>大概浏览参考文献，勾选已经阅读过的参考文献</li></ol><p>再阅读完第一遍的时候，要能回答以下几个问题:</p><ol><li>类别：这是什么类型的论文？是对现有系统的分析还是研究原型的描述等</li><li>背景：他与哪些论文相关？是用哪些理论基础来分析问题？</li><li>正确性：假设是否有效？</li><li>贡献：论文的主要贡献是什么？</li><li>清晰度：论文写得好吗？</li></ol><p>可以根据以上回答，来判断是否要继续阅读该论文。如果对论文不感兴趣，或者说无法读懂论文，那可以选择不再阅读该论文。节省时间。</p><h3 id="第二遍"><a href="#第二遍" class="headerlink" title="第二遍"></a>第二遍</h3><p>在第二遍中要更加仔细地阅读论文，但可以先忽略证明之类地细节。在阅读时可以记一下要点或者做一些评论会比较好。步骤如下。</p><ol><li>仔细阅读论文中的图形、图表等。看是否有误，或者能否完美证明结论等。这将可以看出论文的好坏。</li><li>标记相关未读论文以供进一步阅读。（这是了解论文背景的好方法）</li></ol><p>通过这次阅读，基本可以掌握论文的内容，至少应该能向其他人总结论文的主旨以及支持证据。如果没有读懂，可能是论文难以理解，可以选择不再阅读（如果论文不是硬性要求读懂的话），或者阅读背景材料，看其他论文，等后续再来阅读。也可以坚持下去继续读第三遍。</p><h2 id="第三遍"><a href="#第三遍" class="headerlink" title="第三遍"></a>第三遍</h2><p>第三遍要更详细的去理解文章，尝试虚拟地重新实现论文（作出与作者相同的假设，重新创作作品）。然后再与实际论文对比，找出论文的创新之处，说不定还能找到其隐藏的缺陷。    在本次阅读中需要更加注意细节，要识别并挑战每一个陈述中的每一个假设    </p><p>实际与虚拟的这种比较可以对论文中的证明和演示技术有敏锐的洞察力。在此过程中，还应该记下对未来工作的想法。对于初学者来说，可能需要花费五六个小时。而对于经验丰富的人来说，可能只需花费一小时。   </p><p>通过这次阅读，需要能够根据记忆重建论文的整个结构，并能够识别其优点和缺点。特别是应该能够查明隐含的假设、相关工作的缺失引用以及实验或分析技术的潜在问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KVell</title>
      <link href="/2023/11/07/KVell/"/>
      <url>/2023/11/07/KVell/</url>
      
        <content type="html"><![CDATA[<h1 id="KVell"><a href="#KVell" class="headerlink" title="KVell"></a>KVell</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>以往因为存储设备的读写速度与CPU的运行速度差距很大，导致会让CPU在很长一段时间内处于等待状态。因此以往的优化基本是基于存储设备的优化，比如说LSM的顺序写入，利用CPU来减少对磁盘的访问时间和访问次数，提高IO效率。但现在的存储设备，如SSD的性能相比以前提高了很多，采用的是块访问，支持随机寻址，所以它的顺序IO和随机IO的性能相近。  </p><p>经过测试会发现，现在的CPU性能反而会成为瓶颈。因为以往都是利用CPU来优化存储设备的性能。比如说利用CPU先将写入数据进行排序再写入磁盘中。但现在因为SSD的带宽速度很快，这么做反而只会增加CPU的负担，而对存储设备的优化没有起到很大的帮助。由此现在需要考虑的是精简CPU的使用，来提高性能。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>针对以上所言，我们需要转换LSM树的范式，来精简CPU的使用。  </p><p>新的范式：</p><ol><li>无共享模式：不对磁盘中的数据进行共享。每个工作线程负责一组数据，在执行一系列操作时，不需要对其进行同步操作。</li><li>磁盘中的数据不进行排序，但要在内存中保存索引：不对要写入的数据进行排序，但要在内存中保存索引，以用来快速检索和扫描数据。</li><li>不强制顺序访问，但对IO操作进行批处理：不要求顺序访问数据，但在IO操作很进行批处理，也就是一次性处理多条请求，以减少系统调用数量。</li><li>无提交日志：因为不使用缓存来写入数据，所以不需要提交日志。每次写入的数据就在下次IO处理时写入磁盘中。</li></ol><p>这些技术将应用在KVell中。</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="无共享模式"><a href="#无共享模式" class="headerlink" title="无共享模式"></a>无共享模式</h3><p>在KVell中会使用多个工作线程来管理数据。每个工作线程将处理给定子集键的请求，并且维护用于管理该子集的一组线程专用数据结构。</p><p>关键数据结构包括：</p><ol><li>轻量级的内存B树索引，用于跟踪键在持久存储中的位置。</li><li>I&#x2F;O队列，负责高效地存储和检索来自持久存储中的信息。</li><li>空闲列表（自由列表），部分内存中地磁盘块列表，其中包含存储项目的空闲位置。</li><li>页缓存，KVell使用自己的内部页缓存，不依赖于操作系统级别的构造，只有在扫描操作中，才需要对内存B树索引进行最小的同步。</li></ol><p>传统的KV设计中，大多数主要数据结构都由所有工作线程共享，基本对于每个线程都会进行同步，这会提高CPU的开销。所以KVell避免了这点，采用并行处理请求，减少CPU的开销。</p><h3 id="不在磁盘中排序，而在内存中保留索引"><a href="#不在磁盘中排序，而在内存中保留索引" class="headerlink" title="不在磁盘中排序，而在内存中保留索引"></a>不在磁盘中排序，而在内存中保留索引</h3><p>在KVell中，并不对要写入的数据进行排序，而是采用无序存储的方式。这种存储方式可以减少插入项目的开销，可以直接插入，而不用去寻找正确排序的插入位置。而且也减少了CPU的开销，不需要在写入数据前先对数据进行排序。转而实现在内存中保留索引，也可以提高检索查询数据的速度。</p><p>经过测试，在中大型KV项目的工作负载中，扫描性能并没有因为无序存储而显著下降。</p><h3 id="不强制顺序访问，但对IO操作进行批处理"><a href="#不强制顺序访问，但对IO操作进行批处理" class="headerlink" title="不强制顺序访问，但对IO操作进行批处理"></a>不强制顺序访问，但对IO操作进行批处理</h3><p>在KVell中，所有操作（包括扫描）都对磁盘执行随机访问。由于随机访问与顺序访问一样高效，KVell不会浪费CPU周期来强制执行顺序I&#x2F;O。</p><p>KVell的批处理请求的目标是减少系统调用的数量，以此减少CPU的开销。</p><p>但在进行批处理时要有权衡。要保证工作线程有足够多的请求可以处理，但也不能过多导致高延迟。这样才能保证系统的高效性。</p><p>在具有多个磁盘的配置中，每个工作线程只在一个磁盘上存储文件。</p><h3 id="无提交日志"><a href="#无提交日志" class="headerlink" title="无提交日志"></a>无提交日志</h3><p>KVell仅在数据被持久化到磁盘的最终位置后才确认更新，而不依赖于提交日志。一旦更新提交给工作线程，它将在下一个I&#x2F;O批处理中持久化到磁盘。去掉提交日志使KVell只使用磁盘带宽来处理有用的客户端请求。</p><h2 id="KVell的实现"><a href="#KVell的实现" class="headerlink" title="KVell的实现"></a>KVell的实现</h2><p>KVell的实现并不容易，以下是实现的具体。<a href="https://github.com/BLepers/KVell">KVell的源代码</a></p><h3 id="客户端操作接口"><a href="#客户端操作接口" class="headerlink" title="客户端操作接口"></a>客户端操作接口</h3><p>KVell实现了与LMS树 KV的相同核心接口： 写操作Update(k,v)、读操作Get(k1)、范围查询Scan（k1,k2）。</p><h2 id="磁盘上的数据结构"><a href="#磁盘上的数据结构" class="headerlink" title="磁盘上的数据结构"></a>磁盘上的数据结构</h2><p>将相同的大小范围的数据存储在相同的文件中。这个文件称为”Slab“。KVell以块粒度（通常是4KB，因为一般机器上页面大小就为4KB）访问slab。</p><p>如果项目小于页面大小，也就是一个页面可以存储多个项目，那么就会在slab中为项目添加时间戳、键大小和值大小的前缀。如果项目大于页面大小，那么就会将项目切分成多个块，并且将这些块连接起来（每个块开头有一个时间戳标头）。</p><p>对于项目小于页面大小的，更新采用的是就地更新。而大于的话，采用的是追加更新，并写入slab中，并将旧的项目删除（添加墓碑）。如果是改变项目大小的话，则会将项目写入新的slab中，在旧的slab中删除掉。</p><h3 id="内存上的数据结构"><a href="#内存上的数据结构" class="headerlink" title="内存上的数据结构"></a>内存上的数据结构</h3><ol><li><p>索引：KVell依赖于快速和轻量级的内存索引，具有可预测的插入和查找时间，以查找项目在磁盘上的位置。KVell每个工作线程使用一个内存中的B树来存储项目在磁盘上的位置。项目按（前缀的）键进行索引。我们使用前缀而不是哈希来保持键的顺序以用于范围扫描。</p></li><li><p>页缓存：KVell维护自己的内部页缓存，以避免从持久存储中频繁访问页面，它会记住哪些页面缓存在索引中。当页缓存满的时候，一般采用LRU的方式来消除缓存中的页面。如果页缓存很大时，采用B树的方式会更好。</p></li><li><p>自由列表：当从slab中删除一个项目时，它在slab中的位置会被插入到每个slab的内存堆栈中，我们称之为slab的空闲列表。然后在原来的磁盘位置上标记为墓碑。为了限制内存使用，一般只保留最后N个释放的位置在内存的堆栈中（N一般为64）.目的是为了减少额外的磁盘访问次数。</p></li></ol><h3 id="高效执行I-O"><a href="#高效执行I-O" class="headerlink" title="高效执行I&#x2F;O"></a>高效执行I&#x2F;O</h3><p>KVell采用的是异步I&#x2F;O的方式来处理请求，每次最多批量处理64个请求。多个客户端一起处理请求可以提高I&#x2F;O的执行效率。</p><h3 id="故障模型和恢复"><a href="#故障模型和恢复" class="headerlink" title="故障模型和恢复"></a>故障模型和恢复</h3><p>KVell 当前的实现针对无故障运行进行了优化。如果发生崩溃，则会扫描所有slab并重建内存中的索引。尽管扫描最大限度地提高了顺序磁盘带宽，但对于非常大的数据集，恢复仍然需要几分钟的时间。如果一个项目在磁盘上出现两次（例如，如果将一个项目从一个slab迁移到另一个slab的过程中发生崩溃），则仅将最近的项目保留在内存索引中，并将另一个项目插入空闲列表中。对于大于块大小的项目，KVell 使用时间戳标头丢弃仅部分写入的项目。  </p><p>KVell设计用于能够原子地写入4KB页面的驱动程序。即使在断电的情况下，因为KVell不是在磁盘上原地修改数据，而是将新的值写入到新页面中，然后当新页面的数据被确认后，才将旧数据加入到slab的自由列表中。这样保证了不会因发生中断而导致数据不一致的情况。</p><h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><p>详情参见论文：<a href="https://dl.acm.org/doi/abs/10.1145/3341301.3359628">点击此链接进行跳转</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现有的 KV 存储设计在老一代 SSD 上非常高效，但在现代 SSD 上表现不佳。通过设计新的范式并将其应用在 KVell ，发现其提供了高且可预测的性能以及强大的延迟保证。</p>]]></content>
      
      
      
        <tags>
            
            <tag> key-value </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/2023/10/07/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/10/07/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h1><h2 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h2><p>#表示标题语法，可用#号给标题分级，如一个#号表示一级标题，##表示二级标题这样</p><h2 id="段落语法"><a href="#段落语法" class="headerlink" title="段落语法"></a>段落语法</h2><p>创建段落，要使用空白行将一行或多行文本进行分隔，切忌不要用空格或者制表符（tabs）来缩进段落</p><h2 id="换行语法"><a href="#换行语法" class="headerlink" title="换行语法"></a>换行语法</h2><p>在行末尾添加两个及以上空格，然后按回车键即可创建一个换行</p><p>​    </p><h2 id="强调语法"><a href="#强调语法" class="headerlink" title="强调语法"></a>强调语法</h2><p>分两种，粗体和斜体。</p><ol><li>粗体：在要强调的地方前后各加两个*号</li><li>斜体：在对要斜体表示的地方前后各加一个*号</li></ol><h2 id="引用语法"><a href="#引用语法" class="headerlink" title="引用语法"></a>引用语法</h2><p>要创建块引用，可在段落前添加一个&gt;符号即可。  </p><p>如果要创建多个段落的块引用，即可在段落之间多添加一个&gt;符号</p><p>块引用可以嵌套。在要嵌套的段落前添加一个 <code>&gt;&gt;</code> 符号。</p><h2 id="列表语法"><a href="#列表语法" class="headerlink" title="列表语法"></a>列表语法</h2><ol><li>有序列表:直接在开头加个数字1即可</li><li>无序列表：加星号</li></ol><h2 id="代码语法"><a href="#代码语法" class="headerlink" title="代码语法"></a>代码语法</h2><p>要表示代码可以用&#96;符号表示</p><h2 id="分割线语法"><a href="#分割线语法" class="headerlink" title="分割线语法"></a>分割线语法</h2><p>在单独一行上使用三个或多个*表示</p><hr><h2 id="链接语法"><a href="#链接语法" class="headerlink" title="链接语法"></a>链接语法</h2><p>超链接Markdown语法代码：<code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code></p><p>尖括号可以将URL或者email地址变成可点击的链接 ·&lt;填入地址&gt;·</p><h2 id="图片语法"><a href="#图片语法" class="headerlink" title="图片语法"></a>图片语法</h2><p>插入图片Markdown语法代码：<code>![图片alt](图片链接 &quot;图片title&quot;)</code>。</p><h2 id="转义字符语法"><a href="#转义字符语法" class="headerlink" title="转义字符语法"></a>转义字符语法</h2><p>在字符前加入反斜杠字符\</p><h2 id="内嵌HTML标签"><a href="#内嵌HTML标签" class="headerlink" title="内嵌HTML标签"></a>内嵌HTML标签</h2><p>还没用到，后面再写</p><blockquote><p>摘录自Markdown官方教程</p><p>这些只是基础语法，后续扩展语法，以后更新</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashKV</title>
      <link href="/2023/09/18/HashKV/"/>
      <url>/2023/09/18/HashKV/</url>
      
        <content type="html"><![CDATA[<h1 id="HashKV"><a href="#HashKV" class="headerlink" title="HashKV"></a>HashKV</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>HashKV是一种基于散列数据分组、实现键值分离的存储模型，主要是应用在更新密集型工作负载中。它将值存储划分为固定大小的几个分区，并通过散列其值来确定性地将每个写入的KV对的值映射到对应分区中。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>因为在当前没有一种更新密集型工作负载下的高性能存储模型。Wisckey虽然实现了键值分离，减少了查找和compaction操作的开销，但由于大量的GC操作会使得开销很高，所以提出了HashKV存储模型，来提高吞吐量以及减少写入开销。</p><h2 id="HashKV的设计"><a href="#HashKV的设计" class="headerlink" title="HashKV的设计"></a>HashKV的设计</h2><h3 id="主要的思想"><a href="#主要的思想" class="headerlink" title="主要的思想"></a>主要的思想</h3><ul><li>基于散列的数据分组。通过将散列相关联的键将值映射到值存储中的固定大小的分区</li><li>动态保留空间分配。每个分区的大小是固定的，但可以通过分配保留空间的一部分来动态增长，以至于超过其限制。</li><li>热感知。将冷热键值对存储在不同的分区。</li><li>选择性键值分离。将小尺寸（所占空间小）键值对直接存储在LSM树中，降低开销。</li></ul><h3 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h3><h4 id="HashKV的值存储结构"><a href="#HashKV的值存储结构" class="headerlink" title="HashKV的值存储结构"></a>HashKV的值存储结构</h4><ul><li>Main Segment</li><li>Log Segment</li><li>Reserved Serment</li><li>cold data log Segment</li></ul><h4 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h4><ol><li>首先将key储存到LSM树中</li><li>HashKV将key散列到相对应的主段中，然后将值附加到主段的末尾（如果主段已满则加到日志段中）</li><li>在LSM树中更新值的最新位置。</li></ol><h4 id="实现高写入性能"><a href="#实现高写入性能" class="headerlink" title="实现高写入性能"></a>实现高写入性能</h4><p>用全局内存段表存储每个段组的当前结束位置，以供后续的插入或更新。下次插入或更新数据则可以直接找到正确的写入位置。</p><ul><li>提高写入性能：加入一个写缓存组件，用来存储最近写入的KV对。等到写缓存满了后再刷新到LSM树和值存储区中。</li></ul><h4 id="GC优化"><a href="#GC优化" class="headerlink" title="GC优化"></a>GC优化</h4><p>将键和值都存储在值存储结构中</p><h3 id="垃圾收集（GC）"><a href="#垃圾收集（GC）" class="headerlink" title="垃圾收集（GC）"></a>垃圾收集（GC）</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>回收值存储中无效的键值对，释放空闲空间</p><h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><p>GC以段组为单位进行操作，当保留空间中的空闲日志段被用完时触发</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>选择一个段组</li><li>识别段组中的所有有效对并写回主段中（或者是附加的空闲日志段中）</li><li>释放还未使用的空间以及无效的键值对</li></ol><p>过程优化：</p><ol><li>一般选择的段组是写入量最大的段组（通过跟踪内存段表中每个段表的写入量，并使用堆排序来快速识别哪个段组接受最大的写入量）</li><li>顺序扫描段组中的KV对（会先检查写高速缓存中的最新KV对），而不扫描LSM树（减少开销）</li><li>HashKV会构造临时内存散列表（通过键索引），以缓冲在段组中找到的有效KV对的地址</li></ol><p>问题：hashKV的识别有效键值对，为什么不用扫描LSM树 </p><p>解决方法：墓碑机制，如果说在LSM树中将key删除，那么就会在值存储中将插入一个墓碑键值对，表示该键已不存在。当垃圾收集检查到的时候，可以直接回收。</p><h3 id="热感知"><a href="#热感知" class="headerlink" title="热感知"></a>热感知</h3><h4 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h4><p>将冷热键值对分离，将冷KV对单独存储，以减少数据重写，提高日志结构存储。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>标记法：  </p><ol><li>在GC前先对段组中的KV对进行分类，将基本没更新的KV对视为冷类，将他们的值单独存储在一个区域，而在原来的段组中只保留元数据（即，没有值）并做一个标记</li><li>GC结束时，更新LSM树中的最新值位置</li></ol><p>注：当对含有标签的冷KV对进行更新时，就会将KV对视为热KV对。并且舍弃之前的值。</p><h3 id="选择性KV对分离"><a href="#选择性KV对分离" class="headerlink" title="选择性KV对分离"></a>选择性KV对分离</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><p>将小尺寸（所占空间小）的键值对直接存储在LSM树中</p><h4 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h4><p>减少查找开销</p><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><h4 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h4><p>由于KV分离，且采用的散列分组的形式。所以如果进行范围查询就会导致很多的随机查询，从而提高开销，降低性能。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>预读机制：将值预取到页面缓存中来加速范围扫描。对于每个扫描请求，HashKV在LSM树中的排序键范围内迭代，并对每个值发出预读请求，然后读取所有值并返回排序的KV对。</p><h3 id="崩溃一致性"><a href="#崩溃一致性" class="headerlink" title="崩溃一致性"></a>崩溃一致性</h3><h4 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h4><p>HashKV基于元数据日志记录解决崩溃一致性问题</p><h4 id="措施"><a href="#措施" class="headerlink" title="措施"></a>措施</h4><p>一般针对于两个方面：1.刷新写缓存 2. GC操作</p><h5 id="刷新写缓存"><a href="#刷新写缓存" class="headerlink" title="刷新写缓存"></a>刷新写缓存</h5><ol><li>将高速缓存的KV对刷新到值存储器中</li><li>将元数据更新附加到写入日志</li><li>将提交记录写入日志端</li><li>更新LSM树中的键和元数据</li></ol><h5 id="GC操作"><a href="#GC操作" class="headerlink" title="GC操作"></a>GC操作</h5><p>处理GC操作下的崩溃一致性是不同的，因为它可能会覆盖有效的KV对</p><p>处理方法：</p><ol><li>将有效的KV对以及元数据更新附加到GC日志</li><li>将所有有效KV对写回到段组</li><li>更新LSM树中国中的元数据</li><li>在日志中将GC操作标记为空闲</li></ol><h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><p>。。。。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HashKV是一个适用于更新密集型应用的存储模型，还运用了热感知，选择性键值分离，崩溃一致性等方法来减少开销，提高性能。经测试表明，HashKV有较高的更新吞吐量以及较低的总写入大小。</p><blockquote><p>笔记来源于文章：  <a href="https://www.usenix.org/conference/atc18/presentation/chan">HashKV: Enabling Efficient Updates in KV Storage via Hashing | USENIX</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> key-value </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
