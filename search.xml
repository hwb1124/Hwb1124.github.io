<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/11/07/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E8%AE%BA%E6%96%87/"/>
      <url>/2023/11/07/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E8%AE%BA%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="如何阅读论文"><a href="#如何阅读论文" class="headerlink" title="如何阅读论文"></a>如何阅读论文</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>研究生通常都需要阅读大量的论文，但很多初学者都是盲目的阅读，从头阅读到尾，以至于不能有效的阅读论文。在这里提出了一个三遍阅读法，来提高阅读论文的效率。</p><h2 id="关键思想"><a href="#关键思想" class="headerlink" title="关键思想"></a>关键思想</h2><p>最多阅读论文三遍，但不是从头开始一直读到尾，而是应该带有目的性的去阅读。      </p><p>每一遍阅读都要完成特定的目标，并且是建立在前一遍地基础上；第一遍阅读是要对论文有一个总体的了解。第二遍阅读要掌握论文的内容，但不了解其细节（比如证明假设这些可以不细看）。第三遍就要更深入的理解论文。</p><h2 id="三遍法"><a href="#三遍法" class="headerlink" title="三遍法"></a>三遍法</h2><h3 id="第一遍"><a href="#第一遍" class="headerlink" title="第一遍"></a>第一遍</h3><p>快速阅读论文，大概了解一下论文的思想和研究领域。通常包含以下几个步骤。</p><ol><li>仔细阅读标题、摘要和引言</li><li>阅读章节和子章节标题，但忽略其他所有内容</li><li>阅读结论</li><li>大概浏览参考文献，勾选已经阅读过的参考文献</li></ol><p>再阅读完第一遍的时候，要能回答以下几个问题:</p><ol><li>类别：这是什么类型的论文？是对现有系统的分析还是研究原型的描述等</li><li>背景：他与哪些论文相关？是用哪些理论基础来分析问题？</li><li>正确性：假设是否有效？</li><li>贡献：论文的主要贡献是什么？</li><li>清晰度：论文写得好吗？</li></ol><p>可以根据以上回答，来判断是否要继续阅读该论文。如果对论文不感兴趣，或者说无法读懂论文，那可以选择不再阅读该论文。节省时间。</p><h3 id="第二遍"><a href="#第二遍" class="headerlink" title="第二遍"></a>第二遍</h3><p>在第二遍中要更加仔细地阅读论文，但可以先忽略证明之类地细节。在阅读时可以记一下要点或者做一些评论会比较好。步骤如下。</p><ol><li>仔细阅读论文中的图形、图表等。看是否有误，或者能否完美证明结论等。这将可以看出论文的好坏。</li><li>标记相关未读论文以供进一步阅读。（这是了解论文背景的好方法）</li></ol><p>通过这次阅读，基本可以掌握论文的内容，至少应该能向其他人总结论文的主旨以及支持证据。如果没有读懂，可能是论文难以理解，可以选择不再阅读（如果论文不是硬性要求读懂的话），或者阅读背景材料，看其他论文，等后续再来阅读。也可以坚持下去继续读第三遍。</p><h2 id="第三遍"><a href="#第三遍" class="headerlink" title="第三遍"></a>第三遍</h2><p>第三遍要更详细的去理解文章，尝试虚拟地重新实现论文（作出与作者相同的假设，重新创作作品）。然后再与实际论文对比，找出论文的创新之处，说不定还能找到其隐藏的缺陷。    在本次阅读中需要更加注意细节，要识别并挑战每一个陈述中的每一个假设    </p><p>实际与虚拟的这种比较可以对论文中的证明和演示技术有敏锐的洞察力。在此过程中，还应该记下对未来工作的想法。对于初学者来说，可能需要花费五六个小时。而对于经验丰富的人来说，可能只需花费一小时。   </p><p>通过这次阅读，需要能够根据记忆重建论文的整个结构，并能够识别其优点和缺点。特别是应该能够查明隐含的假设、相关工作的缺失引用以及实验或分析技术的潜在问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KVell</title>
      <link href="/2023/11/07/KVell/"/>
      <url>/2023/11/07/KVell/</url>
      
        <content type="html"><![CDATA[<h1 id="KVell"><a href="#KVell" class="headerlink" title="KVell"></a>KVell</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>以往因为存储设备的读写速度与CPU的运行速度差距很大，导致会让CPU在很长一段时间内处于等待状态。因此以往的优化基本是基于存储设备的优化，比如说LSM的顺序写入，利用CPU来减少对磁盘的访问时间和访问次数，提高IO效率。但现在的存储设备，如SSD的性能相比以前提高了很多，采用的是块访问，支持随机寻址，所以它的顺序IO和随机IO的性能相近。  </p><p>经过测试会发现，现在的CPU性能反而会成为瓶颈。因为以往都是利用CPU来优化存储设备的性能。比如说利用CPU先将写入数据进行排序再写入磁盘中。但现在因为SSD的带宽速度很快，这么做反而只会增加CPU的负担，而对存储设备的优化没有起到很大的帮助。由此现在需要考虑的是精简CPU的使用，来提高性能。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>针对以上所言，我们需要转换LSM树的范式，来精简CPU的使用。  </p><p>新的范式：</p><ol><li>无共享模式：不对磁盘中的数据进行共享。每个工作线程负责一组数据，在执行一系列操作时，不需要对其进行同步操作。</li><li>磁盘中的数据不进行排序，但要在内存中保存索引：不对要写入的数据进行排序，但要在内存中保存索引，以用来快速检索和扫描数据。</li><li>不强制顺序访问，但对IO操作进行批处理：不要求顺序访问数据，但在IO操作很进行批处理，也就是一次性处理多条请求，以减少系统调用数量。</li><li>无提交日志：因为不使用缓存来写入数据，所以不需要提交日志。每次写入的数据就在下次IO处理时写入磁盘中。</li></ol><p>这些技术将应用在KVell中。</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="无共享模式"><a href="#无共享模式" class="headerlink" title="无共享模式"></a>无共享模式</h3><p>在KVell中会使用多个工作线程来管理数据。每个工作线程将处理给定子集键的请求，并且维护用于管理该子集的一组线程专用数据结构。</p><p>关键数据结构包括：</p><ol><li>轻量级的内存B树索引，用于跟踪键在持久存储中的位置。</li><li>I&#x2F;O队列，负责高效地存储和检索来自持久存储中的信息。</li><li>空闲列表（自由列表），部分内存中地磁盘块列表，其中包含存储项目的空闲位置。</li><li>页缓存，KVell使用自己的内部页缓存，不依赖于操作系统级别的构造，只有在扫描操作中，才需要对内存B树索引进行最小的同步。</li></ol><p>传统的KV设计中，大多数主要数据结构都由所有工作线程共享，基本对于每个线程都会进行同步，这会提高CPU的开销。所以KVell避免了这点，采用并行处理请求，减少CPU的开销。</p><h3 id="不在磁盘中排序，而在内存中保留索引"><a href="#不在磁盘中排序，而在内存中保留索引" class="headerlink" title="不在磁盘中排序，而在内存中保留索引"></a>不在磁盘中排序，而在内存中保留索引</h3><p>在KVell中，并不对要写入的数据进行排序，而是采用无序存储的方式。这种存储方式可以减少插入项目的开销，可以直接插入，而不用去寻找正确排序的插入位置。而且也减少了CPU的开销，不需要在写入数据前先对数据进行排序。转而实现在内存中保留索引，也可以提高检索查询数据的速度。</p><p>经过测试，在中大型KV项目的工作负载中，扫描性能并没有因为无序存储而显著下降。</p><h3 id="不强制顺序访问，但对IO操作进行批处理"><a href="#不强制顺序访问，但对IO操作进行批处理" class="headerlink" title="不强制顺序访问，但对IO操作进行批处理"></a>不强制顺序访问，但对IO操作进行批处理</h3><p>在KVell中，所有操作（包括扫描）都对磁盘执行随机访问。由于随机访问与顺序访问一样高效，KVell不会浪费CPU周期来强制执行顺序I&#x2F;O。</p><p>KVell的批处理请求的目标是减少系统调用的数量，以此减少CPU的开销。</p><p>但在进行批处理时要有权衡。要保证工作线程有足够多的请求可以处理，但也不能过多导致高延迟。这样才能保证系统的高效性。</p><p>在具有多个磁盘的配置中，每个工作线程只在一个磁盘上存储文件。</p><h3 id="无提交日志"><a href="#无提交日志" class="headerlink" title="无提交日志"></a>无提交日志</h3><p>KVell仅在数据被持久化到磁盘的最终位置后才确认更新，而不依赖于提交日志。一旦更新提交给工作线程，它将在下一个I&#x2F;O批处理中持久化到磁盘。去掉提交日志使KVell只使用磁盘带宽来处理有用的客户端请求。</p><h2 id="KVell的实现"><a href="#KVell的实现" class="headerlink" title="KVell的实现"></a>KVell的实现</h2><p>KVell的实现并不容易，以下是实现的具体。<a href="https://github.com/BLepers/KVell">KVell的源代码</a></p><h3 id="客户端操作接口"><a href="#客户端操作接口" class="headerlink" title="客户端操作接口"></a>客户端操作接口</h3><p>KVell实现了与LMS树 KV的相同核心接口： 写操作Update(k,v)、读操作Get(k1)、范围查询Scan（k1,k2）。</p><h2 id="磁盘上的数据结构"><a href="#磁盘上的数据结构" class="headerlink" title="磁盘上的数据结构"></a>磁盘上的数据结构</h2><p>将相同的大小范围的数据存储在相同的文件中。这个文件称为”Slab“。KVell以块粒度（通常是4KB，因为一般机器上页面大小就为4KB）访问slab。</p><p>如果项目小于页面大小，也就是一个页面可以存储多个项目，那么就会在slab中为项目添加时间戳、键大小和值大小的前缀。如果项目大于页面大小，那么就会将项目切分成多个块，并且将这些块连接起来（每个块开头有一个时间戳标头）。</p><p>对于项目小于页面大小的，更新采用的是就地更新。而大于的话，采用的是追加更新，并写入slab中，并将旧的项目删除（添加墓碑）。如果是改变项目大小的话，则会将项目写入新的slab中，在旧的slab中删除掉。</p><h3 id="内存上的数据结构"><a href="#内存上的数据结构" class="headerlink" title="内存上的数据结构"></a>内存上的数据结构</h3><ol><li><p>索引：KVell依赖于快速和轻量级的内存索引，具有可预测的插入和查找时间，以查找项目在磁盘上的位置。KVell每个工作线程使用一个内存中的B树来存储项目在磁盘上的位置。项目按（前缀的）键进行索引。我们使用前缀而不是哈希来保持键的顺序以用于范围扫描。</p></li><li><p>页缓存：KVell维护自己的内部页缓存，以避免从持久存储中频繁访问页面，它会记住哪些页面缓存在索引中。当页缓存满的时候，一般采用LRU的方式来消除缓存中的页面。如果页缓存很大时，采用B树的方式会更好。</p></li><li><p>自由列表：当从slab中删除一个项目时，它在slab中的位置会被插入到每个slab的内存堆栈中，我们称之为slab的空闲列表。然后在原来的磁盘位置上标记为墓碑。为了限制内存使用，一般只保留最后N个释放的位置在内存的堆栈中（N一般为64）.目的是为了减少额外的磁盘访问次数。</p></li></ol><h3 id="高效执行I-O"><a href="#高效执行I-O" class="headerlink" title="高效执行I&#x2F;O"></a>高效执行I&#x2F;O</h3><p>KVell采用的是异步I&#x2F;O的方式来处理请求，每次最多批量处理64个请求。多个客户端一起处理请求可以提高I&#x2F;O的执行效率。</p><h3 id="故障模型和恢复"><a href="#故障模型和恢复" class="headerlink" title="故障模型和恢复"></a>故障模型和恢复</h3><p>KVell 当前的实现针对无故障运行进行了优化。如果发生崩溃，则会扫描所有slab并重建内存中的索引。尽管扫描最大限度地提高了顺序磁盘带宽，但对于非常大的数据集，恢复仍然需要几分钟的时间。如果一个项目在磁盘上出现两次（例如，如果将一个项目从一个slab迁移到另一个slab的过程中发生崩溃），则仅将最近的项目保留在内存索引中，并将另一个项目插入空闲列表中。对于大于块大小的项目，KVell 使用时间戳标头丢弃仅部分写入的项目。  </p><p>KVell设计用于能够原子地写入4KB页面的驱动程序。即使在断电的情况下，因为KVell不是在磁盘上原地修改数据，而是将新的值写入到新页面中，然后当新页面的数据被确认后，才将旧数据加入到slab的自由列表中。这样保证了不会因发生中断而导致数据不一致的情况。</p><h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><p>详情参见论文：<a href="https://dl.acm.org/doi/abs/10.1145/3341301.3359628">点击此链接进行跳转</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现有的 KV 存储设计在老一代 SSD 上非常高效，但在现代 SSD 上表现不佳。通过设计新的范式并将其应用在 KVell ，发现其提供了高且可预测的性能以及强大的延迟保证。</p>]]></content>
      
      
      
        <tags>
            
            <tag> key-value </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/2023/10/07/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/10/07/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h1><h2 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h2><p>#表示标题语法，可用#号给标题分级，如一个#号表示一级标题，##表示二级标题这样</p><h2 id="段落语法"><a href="#段落语法" class="headerlink" title="段落语法"></a>段落语法</h2><p>创建段落，要使用空白行将一行或多行文本进行分隔，切忌不要用空格或者制表符（tabs）来缩进段落</p><h2 id="换行语法"><a href="#换行语法" class="headerlink" title="换行语法"></a>换行语法</h2><p>在行末尾添加两个及以上空格，然后按回车键即可创建一个换行</p><p>​    </p><h2 id="强调语法"><a href="#强调语法" class="headerlink" title="强调语法"></a>强调语法</h2><p>分两种，粗体和斜体。</p><ol><li>粗体：在要强调的地方前后各加两个*号</li><li>斜体：在对要斜体表示的地方前后各加一个*号</li></ol><h2 id="引用语法"><a href="#引用语法" class="headerlink" title="引用语法"></a>引用语法</h2><p>要创建块引用，可在段落前添加一个&gt;符号即可。  </p><p>如果要创建多个段落的块引用，即可在段落之间多添加一个&gt;符号</p><p>块引用可以嵌套。在要嵌套的段落前添加一个 <code>&gt;&gt;</code> 符号。</p><h2 id="列表语法"><a href="#列表语法" class="headerlink" title="列表语法"></a>列表语法</h2><ol><li>有序列表:直接在开头加个数字1即可</li><li>无序列表：加星号</li></ol><h2 id="代码语法"><a href="#代码语法" class="headerlink" title="代码语法"></a>代码语法</h2><p>要表示代码可以用&#96;符号表示</p><h2 id="分割线语法"><a href="#分割线语法" class="headerlink" title="分割线语法"></a>分割线语法</h2><p>在单独一行上使用三个或多个*表示</p><hr><h2 id="链接语法"><a href="#链接语法" class="headerlink" title="链接语法"></a>链接语法</h2><p>超链接Markdown语法代码：<code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code></p><p>尖括号可以将URL或者email地址变成可点击的链接 ·&lt;填入地址&gt;·</p><h2 id="图片语法"><a href="#图片语法" class="headerlink" title="图片语法"></a>图片语法</h2><p>插入图片Markdown语法代码：<code>![图片alt](图片链接 &quot;图片title&quot;)</code>。</p><h2 id="转义字符语法"><a href="#转义字符语法" class="headerlink" title="转义字符语法"></a>转义字符语法</h2><p>在字符前加入反斜杠字符\</p><h2 id="内嵌HTML标签"><a href="#内嵌HTML标签" class="headerlink" title="内嵌HTML标签"></a>内嵌HTML标签</h2><p>还没用到，后面再写</p><blockquote><p>摘录自Markdown官方教程</p><p>这些只是基础语法，后续扩展语法，以后更新</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashKV</title>
      <link href="/2023/09/18/HashKV/"/>
      <url>/2023/09/18/HashKV/</url>
      
        <content type="html"><![CDATA[<h1 id="HashKV"><a href="#HashKV" class="headerlink" title="HashKV"></a>HashKV</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>HashKV是一种基于散列数据分组、实现键值分离的存储模型，主要是应用在更新密集型工作负载中。它将值存储划分为固定大小的几个分区，并通过散列其值来确定性地将每个写入的KV对的值映射到对应分区中。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>因为在当前没有一种更新密集型工作负载下的高性能存储模型。Wisckey虽然实现了键值分离，减少了查找和compaction操作的开销，但由于大量的GC操作会使得开销很高，所以提出了HashKV存储模型，来提高吞吐量以及减少写入开销。</p><h2 id="HashKV的设计"><a href="#HashKV的设计" class="headerlink" title="HashKV的设计"></a>HashKV的设计</h2><h3 id="主要的思想"><a href="#主要的思想" class="headerlink" title="主要的思想"></a>主要的思想</h3><ul><li>基于散列的数据分组。通过将散列相关联的键将值映射到值存储中的固定大小的分区</li><li>动态保留空间分配。每个分区的大小是固定的，但可以通过分配保留空间的一部分来动态增长，以至于超过其限制。</li><li>热感知。将冷热键值对存储在不同的分区。</li><li>选择性键值分离。将小尺寸（所占空间小）键值对直接存储在LSM树中，降低开销。</li></ul><h3 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h3><h4 id="HashKV的值存储结构"><a href="#HashKV的值存储结构" class="headerlink" title="HashKV的值存储结构"></a>HashKV的值存储结构</h4><ul><li>Main Segment</li><li>Log Segment</li><li>Reserved Serment</li><li>cold data log Segment</li></ul><h4 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h4><ol><li>首先将key储存到LSM树中</li><li>HashKV将key散列到相对应的主段中，然后将值附加到主段的末尾（如果主段已满则加到日志段中）</li><li>在LSM树中更新值的最新位置。</li></ol><h4 id="实现高写入性能"><a href="#实现高写入性能" class="headerlink" title="实现高写入性能"></a>实现高写入性能</h4><p>用全局内存段表存储每个段组的当前结束位置，以供后续的插入或更新。下次插入或更新数据则可以直接找到正确的写入位置。</p><ul><li>提高写入性能：加入一个写缓存组件，用来存储最近写入的KV对。等到写缓存满了后再刷新到LSM树和值存储区中。</li></ul><h4 id="GC优化"><a href="#GC优化" class="headerlink" title="GC优化"></a>GC优化</h4><p>将键和值都存储在值存储结构中</p><h3 id="垃圾收集（GC）"><a href="#垃圾收集（GC）" class="headerlink" title="垃圾收集（GC）"></a>垃圾收集（GC）</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>回收值存储中无效的键值对，释放空闲空间</p><h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><p>GC以段组为单位进行操作，当保留空间中的空闲日志段被用完时触发</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>选择一个段组</li><li>识别段组中的所有有效对并写回主段中（或者是附加的空闲日志段中）</li><li>释放还未使用的空间以及无效的键值对</li></ol><p>过程优化：</p><ol><li>一般选择的段组是写入量最大的段组（通过跟踪内存段表中每个段表的写入量，并使用堆排序来快速识别哪个段组接受最大的写入量）</li><li>顺序扫描段组中的KV对（会先检查写高速缓存中的最新KV对），而不扫描LSM树（减少开销）</li><li>HashKV会构造临时内存散列表（通过键索引），以缓冲在段组中找到的有效KV对的地址</li></ol><p>问题：hashKV的识别有效键值对，为什么不用扫描LSM树 </p><p>解决方法：墓碑机制，如果说在LSM树中将key删除，那么就会在值存储中将插入一个墓碑键值对，表示该键已不存在。当垃圾收集检查到的时候，可以直接回收。</p><h3 id="热感知"><a href="#热感知" class="headerlink" title="热感知"></a>热感知</h3><h4 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h4><p>将冷热键值对分离，将冷KV对单独存储，以减少数据重写，提高日志结构存储。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>标记法：  </p><ol><li>在GC前先对段组中的KV对进行分类，将基本没更新的KV对视为冷类，将他们的值单独存储在一个区域，而在原来的段组中只保留元数据（即，没有值）并做一个标记</li><li>GC结束时，更新LSM树中的最新值位置</li></ol><p>注：当对含有标签的冷KV对进行更新时，就会将KV对视为热KV对。并且舍弃之前的值。</p><h3 id="选择性KV对分离"><a href="#选择性KV对分离" class="headerlink" title="选择性KV对分离"></a>选择性KV对分离</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><p>将小尺寸（所占空间小）的键值对直接存储在LSM树中</p><h4 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h4><p>减少查找开销</p><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><h4 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h4><p>由于KV分离，且采用的散列分组的形式。所以如果进行范围查询就会导致很多的随机查询，从而提高开销，降低性能。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>预读机制：将值预取到页面缓存中来加速范围扫描。对于每个扫描请求，HashKV在LSM树中的排序键范围内迭代，并对每个值发出预读请求，然后读取所有值并返回排序的KV对。</p><h3 id="崩溃一致性"><a href="#崩溃一致性" class="headerlink" title="崩溃一致性"></a>崩溃一致性</h3><h4 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h4><p>HashKV基于元数据日志记录解决崩溃一致性问题</p><h4 id="措施"><a href="#措施" class="headerlink" title="措施"></a>措施</h4><p>一般针对于两个方面：1.刷新写缓存 2. GC操作</p><h5 id="刷新写缓存"><a href="#刷新写缓存" class="headerlink" title="刷新写缓存"></a>刷新写缓存</h5><ol><li>将高速缓存的KV对刷新到值存储器中</li><li>将元数据更新附加到写入日志</li><li>将提交记录写入日志端</li><li>更新LSM树中的键和元数据</li></ol><h5 id="GC操作"><a href="#GC操作" class="headerlink" title="GC操作"></a>GC操作</h5><p>处理GC操作下的崩溃一致性是不同的，因为它可能会覆盖有效的KV对</p><p>处理方法：</p><ol><li>将有效的KV对以及元数据更新附加到GC日志</li><li>将所有有效KV对写回到段组</li><li>更新LSM树中国中的元数据</li><li>在日志中将GC操作标记为空闲</li></ol><h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><p>。。。。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HashKV是一个适用于更新密集型应用的存储模型，还运用了热感知，选择性键值分离，崩溃一致性等方法来减少开销，提高性能。经测试表明，HashKV有较高的更新吞吐量以及较低的总写入大小。</p><blockquote><p>笔记来源于文章：  <a href="https://www.usenix.org/conference/atc18/presentation/chan">HashKV: Enabling Efficient Updates in KV Storage via Hashing | USENIX</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> key-value </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
