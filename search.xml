<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/11/07/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E8%AE%BA%E6%96%87/"/>
      <url>/2023/11/07/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E8%AE%BA%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="如何阅读论文"><a href="#如何阅读论文" class="headerlink" title="如何阅读论文"></a>如何阅读论文</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>研究生通常都需要阅读大量的论文，但很多初学者都是盲目的阅读，从头阅读到尾，以至于不能有效的阅读论文。在这里提出了一个三遍阅读法，来提高阅读论文的效率。</p><h2 id="关键思想"><a href="#关键思想" class="headerlink" title="关键思想"></a>关键思想</h2><p>最多阅读论文三遍，但不是从头开始一直读到尾，而是应该带有目的性的去阅读。      </p><p>每一遍阅读都要完成特定的目标，并且是建立在前一遍地基础上；第一遍阅读是要对论文有一个总体的了解。第二遍阅读要掌握论文的内容，但不了解其细节（比如证明假设这些可以不细看）。第三遍就要更深入的理解论文。</p><h2 id="三遍法"><a href="#三遍法" class="headerlink" title="三遍法"></a>三遍法</h2><h3 id="第一遍"><a href="#第一遍" class="headerlink" title="第一遍"></a>第一遍</h3><p>快速阅读论文，大概了解一下论文的思想和研究领域。通常包含以下几个步骤。</p><ol><li>仔细阅读标题、摘要和引言</li><li>阅读章节和子章节标题，但忽略其他所有内容</li><li>阅读结论</li><li>大概浏览参考文献，勾选已经阅读过的参考文献</li></ol><p>再阅读完第一遍的时候，要能回答以下几个问题:</p><ol><li>类别：这是什么类型的论文？是对现有系统的分析还是研究原型的描述等</li><li>背景：他与哪些论文相关？是用哪些理论基础来分析问题？</li><li>正确性：假设是否有效？</li><li>贡献：论文的主要贡献是什么？</li><li>清晰度：论文写得好吗？</li></ol><p>可以根据以上回答，来判断是否要继续阅读该论文。如果对论文不感兴趣，或者说无法读懂论文，那可以选择不再阅读该论文。节省时间。</p><h3 id="第二遍"><a href="#第二遍" class="headerlink" title="第二遍"></a>第二遍</h3><p>在第二遍中要更加仔细地阅读论文，但可以先忽略证明之类地细节。在阅读时可以记一下要点或者做一些评论会比较好。步骤如下。</p><ol><li>仔细阅读论文中的图形、图表等。看是否有误，或者能否完美证明结论等。这将可以看出论文的好坏。</li><li>标记相关未读论文以供进一步阅读。（这是了解论文背景的好方法）</li></ol><p>通过这次阅读，基本可以掌握论文的内容，至少应该能向其他人总结论文的主旨以及支持证据。如果没有读懂，可能是论文难以理解，可以选择不再阅读（如果论文不是硬性要求读懂的话），或者阅读背景材料，看其他论文，等后续再来阅读。也可以坚持下去继续读第三遍。</p><h2 id="第三遍"><a href="#第三遍" class="headerlink" title="第三遍"></a>第三遍</h2><p>第三遍要更详细的去理解文章，尝试虚拟地重新实现论文（作出与作者相同的假设，重新创作作品）。然后再与实际论文对比，找出论文的创新之处，说不定还能找到其隐藏的缺陷。    在本次阅读中需要更加注意细节，要识别并挑战每一个陈述中的每一个假设    </p><p>实际与虚拟的这种比较可以对论文中的证明和演示技术有敏锐的洞察力。在此过程中，还应该记下对未来工作的想法。对于初学者来说，可能需要花费五六个小时。而对于经验丰富的人来说，可能只需花费一小时。   </p><p>通过这次阅读，需要能够根据记忆重建论文的整个结构，并能够识别其优点和缺点。特别是应该能够查明隐含的假设、相关工作的缺失引用以及实验或分析技术的潜在问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/2023/10/07/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/10/07/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h1><h2 id="标题语法"><a href="#标题语法" class="headerlink" title="标题语法"></a>标题语法</h2><p>#表示标题语法，可用#号给标题分级，如一个#号表示一级标题，##表示二级标题这样</p><h2 id="段落语法"><a href="#段落语法" class="headerlink" title="段落语法"></a>段落语法</h2><p>创建段落，要使用空白行将一行或多行文本进行分隔，切忌不要用空格或者制表符（tabs）来缩进段落</p><h2 id="换行语法"><a href="#换行语法" class="headerlink" title="换行语法"></a>换行语法</h2><p>在行末尾添加两个及以上空格，然后按回车键即可创建一个换行</p><p>​    </p><h2 id="强调语法"><a href="#强调语法" class="headerlink" title="强调语法"></a>强调语法</h2><p>分两种，粗体和斜体。</p><ol><li>粗体：在要强调的地方前后各加两个*号</li><li>斜体：在对要斜体表示的地方前后各加一个*号</li></ol><h2 id="引用语法"><a href="#引用语法" class="headerlink" title="引用语法"></a>引用语法</h2><p>要创建块引用，可在段落前添加一个&gt;符号即可。  </p><p>如果要创建多个段落的块引用，即可在段落之间多添加一个&gt;符号</p><p>块引用可以嵌套。在要嵌套的段落前添加一个 <code>&gt;&gt;</code> 符号。</p><h2 id="列表语法"><a href="#列表语法" class="headerlink" title="列表语法"></a>列表语法</h2><ol><li>有序列表:直接在开头加个数字1即可</li><li>无序列表：加星号</li></ol><h2 id="代码语法"><a href="#代码语法" class="headerlink" title="代码语法"></a>代码语法</h2><p>要表示代码可以用&#96;符号表示</p><h2 id="分割线语法"><a href="#分割线语法" class="headerlink" title="分割线语法"></a>分割线语法</h2><p>在单独一行上使用三个或多个*表示</p><hr><h2 id="链接语法"><a href="#链接语法" class="headerlink" title="链接语法"></a>链接语法</h2><p>超链接Markdown语法代码：<code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code></p><p>尖括号可以将URL或者email地址变成可点击的链接 ·&lt;填入地址&gt;·</p><h2 id="图片语法"><a href="#图片语法" class="headerlink" title="图片语法"></a>图片语法</h2><p>插入图片Markdown语法代码：<code>![图片alt](图片链接 &quot;图片title&quot;)</code>。</p><h2 id="转义字符语法"><a href="#转义字符语法" class="headerlink" title="转义字符语法"></a>转义字符语法</h2><p>在字符前加入反斜杠字符\</p><h2 id="内嵌HTML标签"><a href="#内嵌HTML标签" class="headerlink" title="内嵌HTML标签"></a>内嵌HTML标签</h2><p>还没用到，后面再写</p><blockquote><p>摘录自Markdown官方教程</p><p>这些只是基础语法，后续扩展语法，以后更新</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashKV</title>
      <link href="/2023/09/18/HashKV/"/>
      <url>/2023/09/18/HashKV/</url>
      
        <content type="html"><![CDATA[<h1 id="HashKV"><a href="#HashKV" class="headerlink" title="HashKV"></a>HashKV</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>HashKV是一种基于散列数据分组、实现键值分离的存储模型，主要是应用在更新密集型工作负载中。它将值存储划分为固定大小的几个分区，并通过散列其值来确定性地将每个写入的KV对的值映射到对应分区中。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>因为在当前没有一种更新密集型工作负载下的高性能存储模型。Wisckey虽然实现了键值分离，减少了查找和compaction操作的开销，但由于大量的GC操作会使得开销很高，所以提出了HashKV存储模型，来提高吞吐量以及减少写入开销。</p><h2 id="HashKV的设计"><a href="#HashKV的设计" class="headerlink" title="HashKV的设计"></a>HashKV的设计</h2><h3 id="主要的思想"><a href="#主要的思想" class="headerlink" title="主要的思想"></a>主要的思想</h3><ul><li>基于散列的数据分组。通过将散列相关联的键将值映射到值存储中的固定大小的分区</li><li>动态保留空间分配。每个分区的大小是固定的，但可以通过分配保留空间的一部分来动态增长，以至于超过其限制。</li><li>热感知。将冷热键值对存储在不同的分区。</li><li>选择性键值分离。将小尺寸（所占空间小）键值对直接存储在LSM树中，降低开销。</li></ul><h3 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h3><h4 id="HashKV的值存储结构"><a href="#HashKV的值存储结构" class="headerlink" title="HashKV的值存储结构"></a>HashKV的值存储结构</h4><ul><li>Main Segment</li><li>Log Segment</li><li>Reserved Serment</li><li>cold data log Segment</li></ul><h4 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h4><ol><li>首先将key储存到LSM树中</li><li>HashKV将key散列到相对应的主段中，然后将值附加到主段的末尾（如果主段已满则加到日志段中）</li><li>在LSM树中更新值的最新位置。</li></ol><h4 id="实现高写入性能"><a href="#实现高写入性能" class="headerlink" title="实现高写入性能"></a>实现高写入性能</h4><p>用全局内存段表存储每个段组的当前结束位置，以供后续的插入或更新。下次插入或更新数据则可以直接找到正确的写入位置。</p><ul><li>提高写入性能：加入一个写缓存组件，用来存储最近写入的KV对。等到写缓存满了后再刷新到LSM树和值存储区中。</li></ul><h4 id="GC优化"><a href="#GC优化" class="headerlink" title="GC优化"></a>GC优化</h4><p>将键和值都存储在值存储结构中</p><h3 id="垃圾收集（GC）"><a href="#垃圾收集（GC）" class="headerlink" title="垃圾收集（GC）"></a>垃圾收集（GC）</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>回收值存储中无效的键值对，释放空闲空间</p><h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><p>GC以段组为单位进行操作，当保留空间中的空闲日志段被用完时触发</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>选择一个段组</li><li>识别段组中的所有有效对并写回主段中（或者是附加的空闲日志段中）</li><li>释放还未使用的空间以及无效的键值对</li></ol><p>过程优化：</p><ol><li>一般选择的段组是写入量最大的段组（通过跟踪内存段表中每个段表的写入量，并使用堆排序来快速识别哪个段组接受最大的写入量）</li><li>顺序扫描段组中的KV对（会先检查写高速缓存中的最新KV对），而不扫描LSM树（减少开销）</li><li>HashKV会构造临时内存散列表（通过键索引），以缓冲在段组中找到的有效KV对的地址</li></ol><p>问题：hashKV的识别有效键值对，为什么不用扫描LSM树 </p><p>解决方法：墓碑机制，如果说在LSM树中将key删除，那么就会在值存储中将插入一个墓碑键值对，表示该键已不存在。当垃圾收集检查到的时候，可以直接回收。</p><h3 id="热感知"><a href="#热感知" class="headerlink" title="热感知"></a>热感知</h3><h4 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h4><p>将冷热键值对分离，将冷KV对单独存储，以减少数据重写，提高日志结构存储。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>标记法：  </p><ol><li>在GC前先对段组中的KV对进行分类，将基本没更新的KV对视为冷类，将他们的值单独存储在一个区域，而在原来的段组中只保留元数据（即，没有值）并做一个标记</li><li>GC结束时，更新LSM树中的最新值位置</li></ol><p>注：当对含有标签的冷KV对进行更新时，就会将KV对视为热KV对。并且舍弃之前的值。</p><h3 id="选择性KV对分离"><a href="#选择性KV对分离" class="headerlink" title="选择性KV对分离"></a>选择性KV对分离</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><p>将小尺寸（所占空间小）的键值对直接存储在LSM树中</p><h4 id="目的-2"><a href="#目的-2" class="headerlink" title="目的"></a>目的</h4><p>减少查找开销</p><h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><h4 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h4><p>由于KV分离，且采用的散列分组的形式。所以如果进行范围查询就会导致很多的随机查询，从而提高开销，降低性能。</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>预读机制：将值预取到页面缓存中来加速范围扫描。对于每个扫描请求，HashKV在LSM树中的排序键范围内迭代，并对每个值发出预读请求，然后读取所有值并返回排序的KV对。</p><h3 id="崩溃一致性"><a href="#崩溃一致性" class="headerlink" title="崩溃一致性"></a>崩溃一致性</h3><h4 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h4><p>HashKV基于元数据日志记录解决崩溃一致性问题</p><h4 id="措施"><a href="#措施" class="headerlink" title="措施"></a>措施</h4><p>一般针对于两个方面：1.刷新写缓存 2. GC操作</p><h5 id="刷新写缓存"><a href="#刷新写缓存" class="headerlink" title="刷新写缓存"></a>刷新写缓存</h5><ol><li>将高速缓存的KV对刷新到值存储器中</li><li>将元数据更新附加到写入日志</li><li>将提交记录写入日志端</li><li>更新LSM树中的键和元数据</li></ol><h5 id="GC操作"><a href="#GC操作" class="headerlink" title="GC操作"></a>GC操作</h5><p>处理GC操作下的崩溃一致性是不同的，因为它可能会覆盖有效的KV对</p><p>处理方法：</p><ol><li>将有效的KV对以及元数据更新附加到GC日志</li><li>将所有有效KV对写回到段组</li><li>更新LSM树中国中的元数据</li><li>在日志中将GC操作标记为空闲</li></ol><h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><p>。。。。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HashKV是一个适用于更新密集型应用的存储模型，还运用了热感知，选择性键值分离，崩溃一致性等方法来减少开销，提高性能。经测试表明，HashKV有较高的更新吞吐量以及较低的总写入大小。</p><blockquote><p>笔记来源于文章：  <a href="https://www.usenix.org/conference/atc18/presentation/chan">HashKV: Enabling Efficient Updates in KV Storage via Hashing | USENIX</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> key-value </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>graph</title>
      <link href="/2023/09/17/graph/"/>
      <url>/2023/09/17/graph/</url>
      
        <content type="html"><![CDATA[<p><img src="/imags/graph/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230916171059.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/17/hello-world/"/>
      <url>/2023/09/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
